\documentclass{article}

\usepackage{luacas}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning,calc}
\usepackage{forest}
\usepackage{minted}
\usemintedstyle{pastie}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[most]{tcolorbox}
    \tcbuselibrary{xparse,documentation}
\usepackage{microtype}
\usepackage{makeidx}
\usepackage{fontawesome5}

\usepackage[
backend=biber,
style=numeric,
]{biblatex}
\addbibresource{sources.bib}

\definecolor{rose}{RGB}{128,0,0}
\definecolor{roseyellow}{RGB}{222,205,99}
\definecolor{roseblue}{RGB}{167,188,214}
\definecolor{rosenavy}{RGB}{79,117,139}
\definecolor{roseorange}{RGB}{232,119,34}
\definecolor{rosegreen}{RGB}{61,68,30}
\definecolor{rosewhite}{RGB}{223,209,167}
\definecolor{rosebrown}{RGB}{108,87,27}
\definecolor{rosegray}{RGB}{84,88,90}

\definecolor{codegreen}{HTML}{49BE25}

\newtcolorbox{codebox}[1][sidebyside]{
    enhanced,skin=bicolor,
    #1,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
}

\newtcolorbox{codehead}[1][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1
}

\DeclareTotalTCBox{\lilcoderef}{O{} m m}{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    enhanced,
    nobeforeafter,
    tcbox raise base,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=1mm,
    right=1mm,
    top=1mm,
    bottom=1mm,
    oversize,
    #1
}{\mintinline{lua}{#2} \mintinline{lua}{#3}}

\usepackage{varwidth}

\newtcolorbox{newcodehead}[2][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1,
    fonttitle=\bfseries\ttfamily\footnotesize,
    coltitle=rosegray,
    attach boxed title to top text right,
    boxed title style={frame hidden,size=small,bottom=-1mm,
    interior style={fill=none,
    top color=white,
    bottom color=white}},
    title={#2}
}

\makeindex

\newcommand{\coderef}[2]{%
\begin{codehead}[sidebyside,segmentation hidden]%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{codehead}%
}

\newcommand{\newcoderef}[3]{%
\begin{newcodehead}[sidebyside,segmentation hidden]{#3}%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{newcodehead}%
}
\usepackage{marginnote}

\begin{document}
\setdescription{style=multiline,
        topsep=10pt,
        leftmargin=6.5cm,
        }

\subsection{Algebra Methods}

Many classes in the algebra package inherit from the {\ttfamily Ring} interface. The {\ttfamily Ring} interface requires the following arithmetic operations, which have corresponding abstract metamethods listed below. Of course, these abstract methods get passed to the appropriate concrete methods in the concrete classes that inherit from {\ttfamily Ring}.

For {\ttfamily Ring} objects {\ttfamily a} and {\ttfamily b}:

\SetLabelAlign{parright}{\parbox[t]{\labelwidth}{\raggedleft#1}}
\begin{description}%[labelwidth = 6.5cm,align=parright]
    \item[\lilcoderef{function a:add(b)}{return a + b}] Adds two ring elements.
    \item[\lilcoderef{function a:sub(b)}{return a - b}] Subtracts one ring element from another. Subtraction has a default implementation in {\ttfamily Ring.lua} as adding the additive inverse, but this can be overwritten if a faster performance method is available.
    \item[\lilcoderef{function a:neg()}{return -a}] Returns the additive inverse of a ring element.
    \item[\lilcoderef{function a:mul(b)}{return a * b}] Multiplies two ring elements.
    \item[\lilcoderef{function a:pow(n)}{return a ^ n}] Raises one ring element to the power of an integer. Exponentiation has a default implementation as repeated multiplication, but this can (and probably should) be overwritten for faster performance.
    \item[\lilcoderef{function a:eq(b)}{return a == b}] Tests if two ring elements are the same.
    \item[\lilcoderef{function a:lt(b)}{return a < b}] Tests if one ring element is less than another under some total order. If the ring does not have a natural total order, this method does not need to be implemented.
    \item[\lilcoderef{function a:le(b)}{return a <= b}] Tests if one ring element is less than or equal to another under some total order. If the ring does not have a natural total order, this method does not need to be implemented.
    \item[\lilcoderef{function a:zero()}{return Ring}] Returns the additive identity of the ring to which \texttt{a} belongs.
    \item[\lilcoderef{function a:one()}{return Ring}] Returns the multiplicative identity of the ring to which \texttt{a} belongs.
\end{description}

\reversemarginpar
Arithmetic\marginnote{\color{rose}\large\faHandPointRight} of {\ttfamily Ring} elements will (generally) not form a {\ttfamily BinaryOperation}. Instead, the appropriate \mintinline{lua}{__RingOperation} is called which then passes the arithmetic to a specific ring, if possible. For example:
\begin{codebox}
    \begin{minted}[breaklines]{latex}
\begin{CAS}
    f = Poly({2,1})
    g = Poly({2,5})
    h = f+g
\end{CAS}
\[ (\print{f}) + (\print{g}) = \print{h} \] 
\end{minted}
\tcblower
\begin{CAS}
    f = Poly({2,1})
    g = Poly({2,5})
    h = f+g
\end{CAS}
\[ (\print{f}) + (\print{g}) = \print{h} \] 
\end{codebox}
So why have the {\ttfamily Ring} class to begin with? Many of the rings in the algebra package are subsets of one another. For instance, integers are subsets of rationals, which are subsets of polynomial rings over the rationals, etc. To smoothly convert objects from one ring to another, it's good to have a class like {\ttfamily Ring} to handle all the ``traffic.'' 

For example, the {\ttfamily RingIdentifier} object acts as a pseudo-class that stores information about the exact ring of an object, including the symbol the ring has if it's a polynomial ring. To perform operations on two elements of different rings, the CAS does the following: 

To get the generic {\ttfamily RingIdentifier} from a class, it uses the static method:
\coderef{function Ring.makering()}{return RingIdentifier}

To get the {\ttfamily RingIdentifier} from a specific instance (element) of a ring, it uses the method:

\coderef{function Ring:getring()}{return RingIdentifier}

So, for example:

\begin{codebox}
    \begin{minted}{lua}
a = Integer(2)/Integer(3)
ring = a:getring()
if ring == Integer.makering() then
    tex.print('same')
else
    tex.print('different')
end
\end{minted}
\tcblower
\luaexec{
a = Integer(2)/Integer(3)
ring = a:getring()
if ring == Integer.makering() then
    tex.print('same rings')
else
    tex.print('different rings')
end
}
\end{codebox}

From there, the CAS computes the smallest {\ttfamily RingIdentifier} that contains the two {\ttfamily RingIdentifier}s as subsets using the static method:

\newcoderef{function Ring.resultantring(ring1,ring2)}{return RingIdentifier}{ring1 RingIdentifier, ring2 RingIdentifier}

So, for example:

\begin{codebox}
    \begin{minted}{lua}
a = Poly({Integer(2),Integer(1)})
b = Integer(3)
ring1 = a:getring()
ring2 = b:getring()
ring = Ring.resultantring(ring1,ring2)
if ring == a:getring() then 
    tex.print('polynomials')
end
\end{minted}
\tcblower
\luaexec{
    a = Poly({Integer(2),Integer(1)})
    b = Integer(3)
    ring1 = a:getring()
    ring2 = b:getring()
    ring = Ring.resultantring(ring1,ring2)
    if ring == a:getring() then 
        tex.print('polynomials')
    end
}
\end{codebox}

Finally, the CAS converts both objects into the resultant {\ttfamily RingIdentifier}, if possible,  using the method:

\coderef{function Ring:inring(ring)}{return Ring}

So, for example: 

\begin{codebox}
    \begin{minted}{lua}
b = b:inring(ring)
if b:type() == PolynomialRing then 
    tex.print('b is a polynomial now')
end
\end{minted}
\tcblower
\luaexec{
    b = b:inring(ring)
    if b:type() == PolynomialRing then 
        tex.print('b is a polynomial now')
    end
}
\end{codebox}

Finally, the CAS is able to perform the operation with the correct \mintinline{lua}{__RingOperation}. This all happens within the hierarchy of \texttt{Ring} classes automatically:
\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    a = Poly({1/2,3,1})
    b = 1/2
    c = a+b
\end{CAS}
\[ \print{a} + \print{b} = \print{c} \] 
\end{minted}
\tcblower
\begin{CAS}
    a = Poly({1/2,3,1})
    b = 2/3
    c = a+b
\end{CAS}
\[ \print{a} + \print{b} = \print{c} \] 
\end{codebox}


To add another class that implements {\ttfamily Ring} and has proper conversion abilities, the {\ttfamily resultantring} method needs to be updated to include all possible resultant rings constructed from the new ring and existing rings. The other three methods need to be implemented as well.

We now discuss the more arithmetic methods included in the algebra package. 

\coderef{function PolynomialRing.derivative()}{return PolynomialRing}

Returns the formal derivative of the given polynomial. For example:
\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    f = Poly({1,1,1/2,1/6})
    g = f:derivative()
\end{CAS}
\[ \print{f} \xrightarrow{d/dx}
    \print{g} \] 
\end{minted}
\tcblower
\begin{CAS}
    f = Poly({1,1,1/2,1/6})
    g = f:derivative()
\end{CAS}
\[ \print{f} \xrightarrow{d/dx}
    \print{g} \] 
\end{codebox}

\newcoderef{function PolynomialRing:divremainder(poly1)}{return poly2,poly3}{poly1 PolynomialRing,..., poly3 PolynomialRing}

Uses synthetic division to return the quotient (\texttt{poly2}) and remainder (\texttt{poly3}) of \texttt{self/poly1}. For example:

\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    f = Poly({2,2,1})
    g = Poly({1,1})
    q,r = f:divremainder(g)
\end{CAS}
\[ \print{f} = (\print{g})(\print{q}) 
    + \print{r} \] 
\end{minted}
\tcblower
\begin{CAS}
    f = Poly({2,2,1})
    g = Poly({1,1})
    q,r = f:divremainder(g)
\end{CAS}
\[ \print{f} = (\print{g})(\print{q}) 
    + \print{r} \]
\end{codebox}

\newcoderef{function PolynomialRing.extendedgcd(poly1,poly2)}{return poly3, poly4, poly5}{poly1 PolynomialRing, poly2 PolynomialRing, ..., poly5 PolynomialRing}

Given two \texttt{PolynomialRing} elements \texttt{poly1,poly2} returns:
\begin{itemize}
    \item \texttt{poly3}: the gcd of \texttt{poly1,poly2};
    \item \texttt{poly4,poly5}: the coefficients from Bezout's lemma via the extended gcd. 
\end{itemize}
For example:

\begin{codebox}[]
    \begin{minted}{latex}
\begin{CAS}
    vars('x')
    f = topoly((x-1)*(x-2)*(x-3))
    g = topoly((x-1)*(x+2)*(x+3))
    h,a,b = PolynomialRing.extendedgcd(f,g)
\end{CAS}
\[ \print{f*a+g*b} = (\print{f})\left( \print{a} \right) + 
    (\print{g})\left(\print{b} \right)\] 
\end{minted}
\tcblower
\begin{CAS}
    vars('x')
    f = topoly((x-1)*(x-2)*(x-3))
    g = topoly((x-1)*(x+2)*(x+3))
    h,a,b = PolynomialRing.extendedgcd(f,g)
\end{CAS}
\[ \print{f*a+g*b} = (\print{f})\left( \print{a} \right) + 
    (\print{g})\left(\print{b} \right)\] 
\end{codebox}

\subsubsection*{Parsing}

The function \texttt{extendedgcd()} is a shortcut to \texttt{Polynomial.extendedgcd()}:

\begin{codebox}[]
    \begin{minted}{latex}
\begin{CAS}
    f = topoly((x+2)*(x-3))
    g = topoly((x+4)*(x-3))
    h,a,b = extendedgcd(f,g)
\end{CAS}
\[ \print{h} = (\print{f}) \left( \print{a} \right) + 
    (\print{g})\left( \print{b} \right). \] 
\end{minted}
\tcblower
\begin{CAS}
    f = topoly((x+2)*(x-3))
    g = topoly((x+4)*(x-3))
    h,a,b = extendedgcd(f,g)
\end{CAS}
\[ \print{h} = (\print{f}) \left( \print{a} \right) + (\print{g})\left( \print{b} \right). \] 
\end{codebox}

\coderef{function PolynomialRing:evaluateAt(Expression)}{return Expression}

Uses Horner's rule to evaluate a polynomial at \texttt{Expression}. Typically, the input \texttt{Expression} is an \texttt{Integer} or \texttt{Rational}. For example:

\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    f = Poly({2,2,1})
    p = f:evaluateat(1/2)
\end{CAS}
\[ \left. \print{f} \right|_{x=1/2}
    = \print{p} \]
\end{minted}
\tcblower
\begin{CAS}
    f = Poly({2,2,1})
    p = f:evaluateat(1/2)
\end{CAS}
\[ \left. \print{f} \right|_{x=1/2}
    = \print{p} \]
\end{codebox}

\coderef{function PolynomialRing:factor()}{return BinaryOperation}

Factors the given polynomial into irreducible terms. For example:

\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    f = Poly({8,24,32,24,10,2})
    a = f:factor()
\end{CAS}
\[ \print{a} \] 
\end{minted}
\tcblower
\begin{CAS}
    f = Poly({8,24,32,24,10,2})
    a = f:factor()
\end{CAS}
\[ \print{a} \] 
\end{codebox}

\newcoderef{function PolynomialRing:freeof(symbol)}{return bool}{symbol SymbolExpression}

Checks the value of the field \mintinline{lua}{PolynomialRing.symbol} against \texttt{symbol}; returns \mintinline{lua}{true} if these symbols are not equal, and returns \mintinline{lua}{false} otherwise. 

Recall: the default symbol for \texttt{Poly} is \texttt{'x'}. So, for example:
\begin{codebox}[]
    \begin{minted}{latex}
\begin{CAS}
    f = Poly({2,2,1})
    vars('t')
    if f:freeof(t) then 
        tex.print('$',f:tolatex(),'$ is free of $',t:tolatex(),'$')
    else 
        tex.print('$',f:tolatex(),'$ is bound by $',t:tolatex(),'$')
    end
\end{CAS}
\end{minted}
\tcblower
\begin{CAS}
    f = Poly({2,2,1})
    vars('t')
    if f:freeof(t) then 
        tex.print('$',f:tolatex(),'$ is free of $',t:tolatex(),'$')
    else 
        tex.print('$',f:tolatex(),'$ is bound by $',t:tolatex(),'$')
    end
\end{CAS}
\end{codebox}

\newcoderef{function PolynomialRing.gcd(poly1,poly2)}{return poly3}{poly1 PolynomialRing,..., poly3 PolynomialRing}

Returns the greatest common divisor of two polynomials in a ring (assuming \texttt{poly1,poly2} belong to a Euclidean domain). For example:

\begin{codebox}[]
    \begin{minted}{latex}
\begin{CAS}
    vars('x')
    f = topoly((x^2+1)*(x-1))
    g = topoly((x^2+1)*(x+2))
    h = PolynomialRing.gcd(f,g)
\end{CAS}
\[ \gcd(\print{f},\print{g}) = \print{h} \] 
\end{minted}
\tcblower
\begin{CAS}
    vars('x')
    f = topoly((x^2+1)*(x-1))
    g = topoly((x^2+1)*(x+2))
    h = PolynomialRing.gcd(f,g)
\end{CAS}
\[ \gcd(\print{f},\print{g}) = \print{h} \] 
\end{codebox}

\coderef{function PolynomialRing.isatomic()}{return false}
\coderef{function PolynomialRing.isconstant()}{return false}

The inheritances from \texttt{ConstantExpression} are overridden for the \texttt{PolynomialRing} class.

\newcoderef{function PolynomialRing.monicgcdremainders(poly1,poly2)}{return table<number, Ring>}{poly1 PolynomialRing, poly2 PolynomialRing}

Given two polynomials \texttt{poly1} and \texttt{poly2}, returns a list of the remainders generated by the monic Euclidean algorithm.
\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
  vars('x')
  f = topoly(x^13-1)
  g = topoly(x^8-1)
  r = PolynomialRing.monicgcdremainders(f,g)
\end{CAS}
\luaexec{
  for i=1,\#r do 
    tex.print('\\[', r[i]:tolatex(), '\\]')
  end
}
\end{minted}
\tcblower
\begin{CAS}
    vars('x')
    f = topoly(x^13-1)
    g = topoly(x^8-1)
    r = PolynomialRing.monicgcdremainders(f,g)
\end{CAS}
\luaexec{
    for i=1,\#r do 
        tex.print('\\[', r[i]:tolatex(), '\\]')
    end
}
\end{codebox}

\coderef{function PolynomialRing.mul_rec(poly1,poly2)}{return PolynomialRing}

Performs Karatsuba multiplication without constructing new polynomials recursively. But grade-school multiplication of polynomials is actually faster here up to a very large polynomial size due to Lua's overhead.

\newcoderef{function PolynomialRing.partialfractions(g,f,ffactors)}{return BinaryOperation}{g PolynomialRing, f PolynomialRing, ffactors BinaryOperation}
Returns the partial fraction decomposition of the rational function \texttt{g/f} given \texttt{PolynomialRing}s \texttt{g, f}, and some (not necessarily irreducible) factorization of \texttt{f}. If the factorization is omitted, the irreducible factorization is used. The degree of \texttt{g} must be less than the degree of \texttt{f}.

\begin{codebox}[]
    \begin{minted}{latex}
\begin{CAS}
    g = topoly(4*x^2+2*x+2)
    f = topoly((x^2+1)^2*(x+1))
    a = PolynomialRing.partialfractions(g,f)
\end{CAS}
\[ \print{g/f} = \print*{a} \] 
\end{minted}
\tcblower
\begin{CAS}
    g = topoly(4*x^2+2*x+2)
    f = topoly((x^2+1)^2*(x+1))
    a = PolynomialRing.partialfractions(g,f)
\end{CAS}
\[ \print{g/f} = \print*{a} \] 
\end{codebox}

\subsubsection*{Parsing}

The function \mintinline{lua}{parfrac()} shortcuts the more long winded \mintinline{lua}{PolynomialRing.partialfractions()}. Additionally, the \texttt{parfrac} function will automatically try to convert the first two arguments to the \texttt{PolynomialRing} type via \mintinline{lua}{topoly()}. 
\begin{codebox}[]
    \begin{minted}{latex}
\begin{CAS}
    g = 4*x^2+2*x+2
    f = (x^2+1)^2*(x+1)
    a = parfrac(g,f)
\end{CAS}
\[ \print{g/f} = \print*{a} \] 
\end{minted}
\tcblower
\begin{CAS}
    g = 4*x^2+2*x+2
    f = (x^2+1)^2*(x+1)
    a = parfrac(g,f)
\end{CAS}
\[ \print{g/f} = \print*{a} \] 
\end{codebox}

\newcoderef{function PolynomialRing:rationalroots()}{return remaining, roots}{remaining PolynomialRing, roots table<number,PolynomialRing>}

This method finds the factors of \texttt{PolynomialRing} (up to multiplicity) that correspond to rational roots; these factors are stored in a table \texttt{roots} and returned in the second output of the method. Those factors are then divided out of \texttt{Polynomialring}; the \texttt{PolynomialRing} that remains is returned in the first output of the method. For example: 

\begin{codebox}
    \begin{minted}[breaklines,fontsize=\small]{latex}
\begin{CAS}
  f = topoly((x-1)^2*(x+1)*(x^2+1))
  g,r = f:rationalroots()
\end{CAS}
The factors of $f$ corresponding to rational roots are:
\luaexec{
  for i =1, \#r do 
    tex.print('\\[', r[i]:tolatex(), '\\]')
  end
}
The part of $f$ that remains after dividing out these linear terms is:
\[ \print{g} \]
\end{minted}
\tcblower
\begin{CAS}
    f = topoly((x-1)^2*(x+1)*(x^2+1))
    g,r = f:rationalroots()
  \end{CAS}
  The factors of $f$ corresponding to rational roots are:
  \luaexec{
    for i =1, \#r do 
      tex.print('\\[', r[i]:tolatex(), '\\]')
    end
  }
  The part of $f$ that remains after dividing out these linear terms is:
  \[ \print{g} \]
\end{codebox}


\end{document}