\documentclass{article}

\usepackage{luacas}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning,calc}
\usepackage{forest}
\usepackage{minted}
\usemintedstyle{pastie}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[most]{tcolorbox}
    \tcbuselibrary{xparse,documentation}
\usepackage{microtype}
\usepackage{makeidx}
\usepackage{fontawesome}

\usepackage[
backend=biber,
style=numeric,
]{biblatex}
\addbibresource{sources.bib}

\definecolor{rose}{RGB}{128,0,0}
\definecolor{roseyellow}{RGB}{222,205,99}
\definecolor{roseblue}{RGB}{167,188,214}
\definecolor{rosenavy}{RGB}{79,117,139}
\definecolor{roseorange}{RGB}{232,119,34}
\definecolor{rosegreen}{RGB}{61,68,30}
\definecolor{rosewhite}{RGB}{223,209,167}
\definecolor{rosebrown}{RGB}{108,87,27}
\definecolor{rosegray}{RGB}{84,88,90}

\definecolor{codegreen}{HTML}{49BE25}

\newtcolorbox{codebox}[1][sidebyside]{
    enhanced,skin=bicolor,
    #1,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
}

\newtcolorbox{codehead}[1][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1
}

\usepackage{varwidth}

\newtcolorbox{newcodehead}[2][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1,
    fonttitle=\bfseries\ttfamily\footnotesize,
    coltitle=rosegray,
    attach boxed title to top text right,
    boxed title style={frame hidden,size=small,bottom=-1mm,
    interior style={fill=none,
    top color=white,
    bottom color=white}},
    title={#2}
}

\makeindex

\newcommand{\coderef}[2]{%
\begin{codehead}[sidebyside,segmentation hidden]%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{codehead}%
}

\newcommand{\newcoderef}[3]{%
\begin{newcodehead}[sidebyside,segmentation hidden]{#3}%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{newcodehead}%
}

\begin{document}
\setdescription{style=multiline,
        topsep=10pt,
        leftmargin=5cm,
        }

\subsection{Algebra Classes}

The algebra package contains functionality for arbitrary-precision arithmetic, polynomial arithmetic and factoring, symbolic root finding, and logarithm and trigonometric expression classes. It requires the core package to be loaded.

The abstract classes in the algebra module all inherit from the \texttt{ConstantExpression} branch in the inheritance tree:

\begin{itemize}
    \item \texttt{Ring}
    \item \texttt{EuclideanDomain}
    \item \texttt{Field}
\end{itemize}    

The {\ttfamily EuclideanDomain} class is a sub-class to the {\ttfamily Ring} class, and the {\ttfamily Field} class is a sub-class to the {\ttfamily EuclideanDomain} class.

The following concrete classes inherit from the {\ttfamily Ring} class (or one of the sub-classes mentioned above). However, not all of them are proper {\ttfamily ConstantExpression}s, so some of them override the {\ttfamily isconstant()} method.

\begin{itemize}
    \item {\ttfamily Integer} 
    \item {\ttfamily IntegerModN}
    \item {\ttfamily Rational}
    \item {\ttfamily PolynomialRing}
\end{itemize}

The other concrete classes in the Algebra package do not inherit from the {\ttfamily Ring} interface, instead they inherit from the {\ttfamily CompoundExpression} interface:

\begin{itemize}
    \item {\ttfamily AbsExpression}
    \item {\ttfamily Logarithm}
    \item {\ttfamily FactorialExpression}
    \item {\ttfamily SqrtExpression}
    \item {\ttfamily TrigExpression}
    \item {\ttfamily RootExpression}
\end{itemize}

\newcoderef{function Integer:new(n)}{return Integer}{n number|string|Integer}
\index{Algebra!Classes!\texttt{SymbolExpression}}
\addcontentsline{toc}{subsubsection}{\ttfamily Integer}

Takes a string, number, or {\ttfamily Integer} input and constructs an \texttt{Integer}. Since Lua can only store integers exactly up to a certain point, it is recommended to use strings to build large integers.

\begin{codebox}
    \begin{minted}{lua}
a = Integer(-12435)
b = Integer('-12435')
tex.print('\\[',a:tolatex(),
    '=',
    b:tolatex(),
    '\\]')
\end{minted}
\tcblower
\directlua{
    a = Integer(-12435)
    b = Integer('-12435')
    tex.print('\\[',a:tolatex(),
        '=',
        b:tolatex(),
        '\\]')
}
\end{codebox}
An {\ttfamily Integer} is a table 1-indexed by Lua numbers consisting of Lua number. For example:
\begin{codebox}
    \begin{minted}{lua}
tex.print(tostring(b[1]))
\end{minted}
\tcblower
\directlua{
    tex.print(tostring(b[1]))
}
\end{codebox}
Whereas:
\begin{codebox}[]
    \begin{minted}{lua}
c = Integer('7240531360949381947528131508')
tex.print('The first 14 digits of c:', tostring(c[1]),'. ')
tex.print('The last 14 digits of c:', tostring([2]),'.')
\end{minted}
\tcblower
\directlua{
    c = Integer('7240531360949381947528131508')
    tex.print('The first 14 digits of c:', tostring(c[1]),'. ')
    tex.print('The last 14 digits of c:', tostring(c[2]),'.')
}
\end{codebox}

The global field {\ttfamily DIGITSIZE} is set to \texttt{14} so that exact arithmetic on {\ttfamily Integer}s can be done as efficiently as possible while respecting Lua's limitations.

\subsubsection*{Fields}
{\ttfamily Integer}s have a {\ttfamily .sign} field which contains the Lua number {\ttfamily 1} or {\ttfamily -1} depending on whether \texttt{Integer} is positive or negative. 
\begin{codebox}[]
    \begin{minted}{lua}
tex.print('The sign of',tostring(b),'is:',tostring(b.sign))
\end{minted}
\tcblower
\directlua{
    tex.print('The sign of',
        tostring(b),
        'is:',
        tostring(b.sign))
}
\end{codebox}

\subsubsection*{Parsing}

The contents of the environment \mintinline{latex}{\begin{CAS}..\end{CAS}} are wrapped in the argument of a function \mintinline{lua}{CASparse()} which, among other things, seeks out digit strings intended to represent integers, and wraps those in \texttt{Integer('...')}. 

\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    c = 7240531360949381947528131508
\end{CAS}
\directlua{
    tex.print(tostring(c[1]))
} 
\end{minted}
\tcblower
\begin{CAS}
    c = 7240531360949381947528131508
\end{CAS}
\directlua{
    tex.print(tostring(c[1]))
} 
\end{codebox}

\newcoderef{function IntegerModN:new(i,n)}{return IntegerModN}{i Integer, n Integer}
\index{Algebra!Classes!\texttt{IntegerModN}}
\addcontentsline{toc}{subsubsection}{\ttfamily IntegerModN}

Takes an {\ttfamily Integer i} and {\ttfamily Integer n} and constructs an integer in the ring $\mathbb{Z}_n$, the integers modulo $n$. 

\begin{codebox}[]
    \begin{minted}{lua}
i = Integer(143)
n = Integer(57)
a = IntegerModN(i,n)
tex.print('\\[',i:tolatex(),'\\equiv',a:tolatex(),'\\]')
\end{minted}
\tcblower
\luaexec{
    i = Integer(143)
    n = Integer(57)
    a = IntegerModN(i,n)
    tex.print('\\[',i:tolatex(),'\\equiv',a:tolatex(),'\\]')
}
\end{codebox}

\subsubsection*{Fields}

{\ttfamily IntegerModN}s have two fields: {\ttfamily .element} and {\ttfamily .modulus}. The reduced input \texttt{i} is stored in {\ttfamily .element} while the input \texttt{n} is stored in {\ttfamily .modulus}:

\begin{codebox}
    \begin{minted}[fontsize=\small]{lua}
tex.print(a.element:tolatex(),'\\newline')
tex.print(a.modulus:tolatex())
\end{minted}
\tcblower
\luaexec{
    tex.print(a.element:tolatex(),'\\newline')
    tex.print(a.modulus:tolatex())
}
\end{codebox}

\subsubsection*{Parsing}

The function \texttt{Mod(,)} is a shortcut for \texttt{IntegerModN(,)}:
\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    i = 143
    n = 57
    a = Mod(i,n)
\end{CAS}
\[ \print{i} \equiv \print{a} \] 
\end{minted}
\tcblower
\begin{CAS}
    i = 143
    n = 57
    a = Mod(i,n)
\end{CAS}
\[ \print{i} \equiv \print{a} \] 
\end{codebox}

\newcoderef{function PolynomialRing:new(coefficients, symbol, degree)}{return PolynomialRing}{coefficients table<number,Ring>, symbol string|SymbolExpression, degree Integer}
\index{Algebra!Classes!\texttt{PolynomialRing}}
\addcontentsline{toc}{subsubsection}{\ttfamily PolynomialRing}

Takes a table of {\ttfamily coefficients} not necessarily in the same ring and a {\ttfamily symbol} to create a polynomial in the polynomial ring with the given {\ttfamily symbol} and coefficients in the smallest possible ring that includes all of the coefficients. If {\ttfamily degree} is omitted, it will calculate the degree of the polynomial automatically. The list can either be one-indexed or zero-indexed, but if it is one-indexed, the internal list of coefficients will still be zero-indexed.

\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
  f = PolynomialRing({0,1/3,-1/2,1/6},'t')
\end{CAS}
\[ \print{f} \] 
\end{minted}
\tcblower
\begin{CAS}
    f = PolynomialRing({0,1/3,-1/2,1/6},'t')
\end{CAS}
\[ \print{f} \] 
\end{codebox}

\subsubsection*{Fields}

{\ttfamily PolynomialRing}s have several fields:
\begin{itemize}
    \item {\ttfamily f.coefficients} stores the 0-indexed table of coefficients of {\ttfamily f};
    \item {\ttfamily f.degree} stores the {\ttfamily Integer} that represents the degree of {\ttfamily f};
    \item {\ttfamily f.symbol} stores the {\ttfamily string} representing the variable or {\ttfamily symbol} of {\ttfamily f}.
\end{itemize}
For example:
\begin{codebox}
    \begin{minted}{lua}
for i=0,f.degree:asnumber() do
  tex.print(
    '\\[',
    f.coefficients[i]:tolatex(),
    f.symbol,
    '^{',
    tostring(i),
    '}\\]'
  )
end
\end{minted}
\tcblower
\luaexec{
for i=0,f.degree:asnumber() do
  tex.print(
    '\\[',
    f.coefficients[i]:tolatex(),
    f.symbol,
    '^{',
    tostring(i),
    '}\\]'
  )
  end
}
\end{codebox}

\subsubsection*{Parsing}

The function \mintinline{lua}{Poly()} is a shortcut for \mintinline{lua}{PolynomialRing:new()}. If the second argument \texttt{symbol} is omitted, then the default is \texttt{'x'}:

\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    f = Poly({0,1/3,-1/2,1/6})
\end{CAS}
\[ \print{f} \] 
\end{minted}
\tcblower
\begin{CAS}
    f = Poly({0,1/3,-1/2,1/6})
\end{CAS}
\[ \print{f} \] 
\end{codebox}

Alternatively, one could typeset the polynomial naturally and use the \texttt{topoly()} function. This is the same as the \texttt{topolynomial()} method except that the \texttt{autosimplify()} method is automatically called first:

\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    f = 1/3*x - 1/2*x^2 + 1/6*x^3
    f = topoly(f)
\end{CAS}
\[ \print{f} \] 
\end{minted}
\tcblower
\begin{CAS}
    f = 1/3*x - 1/2*x^2 + 1/6*x^3
    f = topoly(f)
\end{CAS}
\[ \print{f} \] 
\end{codebox}

\newcoderef{function Rational:new(n,d,keep)}{return Rational}{n Ring, d Ring, keep bool}
\index{Algebra!Classes!\texttt{Rational}}
\addcontentsline{toc}{subsubsection}{\ttfamily Rational}

Takes a numerator {\ttfamily n} and denominator {\ttfamily d} in the same {\ttfamily Ring} and constructs a rational expression in the field of fractions over that ring. For the integers, this is the ring of rational numbers. If the {\ttfamily keep} flag is omitted, the constructed object will be simplified to have smallest possible denominator, possibly returning an object in the original {\ttfamily Ring}. Typically, the {\ttfamily Ring} will be either {\ttfamily Integer} or {\ttfamily PolynomialRing}, so {\ttfamily Rational} can be viewed as a constructor for either a rational number or a rational function. 

For example:
\begin{codebox}
    \begin{minted}{lua}
a = Integer(6)
b = Integer(10)
c = Rational(a,b)
tex.print('\\[',c:tolatex(),'\\]')
\end{minted}
\tcblower
\luaexec{
    a = Integer(6)
    b = Integer(10)
    c = Rational(a,b)
    tex.print('\\[',c:tolatex(),'\\]')
}
\end{codebox}
But also:
\begin{codebox}
    \begin{minted}{lua}
a = Poly({Integer(2),Integer(3)})
b = Poly({Integer(4),Integer(1)})
c = Rational(a,b)
tex.print('\\[',c:tolatex(),'\\]')
\end{minted}
\tcblower
\luaexec{
a = Poly({Integer(2),Integer(3)})
b = Poly({Integer(4),Integer(1)})
c = Rational(a,b)
tex.print('\\[',c:tolatex(),'\\]')
}
\end{codebox}

\subsubsection*{Parsing}

\texttt{Raional}s are constructed naturally using the \texttt{/} operator:

\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    a = Poly({2,3})
    b = Poly({4,1})
    c = a/b
\end{CAS}
\[ \print{c} \] 
\end{minted}
\tcblower
\begin{CAS}
    a = Poly({2,3})
    b = Poly({4,1})
    c = a/b
\end{CAS}
\[ \print{c} \] 
\end{codebox}

\end{document}